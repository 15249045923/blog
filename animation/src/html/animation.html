<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="renderer" content="webkit">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <title>animation</title>
    <link rel="stylesheet" href="@@CONTEXT_PATH/css/animation.css"/>
</head>
<body>
<h1 class="tc">animation-fill-mode属性值详解</h1>
<div class="auto pct80 pt50 pb50">
    <h2>1. 动画未定义第一帧或最后一帧时</h2>
    <div class="wrapp fix mb20">
        <div class="box r">
            <div class="target target_1"></div>
        </div>
        <div class="cell">
               <pre class="mr10">
.target_1:hover {
  animation-name: move_1;
  animation-duration: 2s;
  animation-delay: 1s;
  animation-fill-mode: both;
}

@keyframes move_1 {
  50% {
    transform: translate(0,50px);
  }
}
    </pre>
            <div class="pr10">
                右边的动画中，.target元素定义了一个move_1的动画，但是这个动画没有定义0%，也没有定义100%，仅仅定义了50%。尽管animation-fill-mode已经被设置为
                both，但是在动画delay的那小段时间内以及在动画完成之后，.target并没有应用动画move_1在50%的时候的样式。说明animation-fill-mode的两个属性值
                forwards跟backwards，必须有对应的0%或100%的定义才能生效。
            </div>
        </div>
    </div>
    <h2>2. 动画正常定义第一帧或最后一帧时</h2>
    <div class="wrapp fix mb20">
        <div class="box r">
            <div class="target target_2"></div>
        </div>
        <div class="cell">
               <pre class="mr10">
.target_2:hover {
  animation-name: move_2;
  animation-duration: 2s;
  animation-delay: 1s;
  animation-fill-mode: both;
}

@keyframes move_2 {
  0% {
    transform: translate(-50px,0);
  }

  50% {
    transform: translate(0,50px);
  }

  100% {
    transform: translate(50px,0);
  }
}
    </pre>
            <div class="pr10">
                对比.target_1，上面的动画中.target_2，由于定义的动画move_2同时定义了0%和100%，所以在动画delay的那一小段时间内，应用到了move_2
                0%定义的样式，当你把鼠标移入.target_2的时候，能够感觉的元素的瞬移；在动画完成之后，只要鼠标不离开.target_2，元素依然保持着move_2
                100%定义的样式。这就是animation-fill-mode两个属性值的作用。
            </div>
        </div>
    </div>
    <h2>3. 动画第一帧或最后一帧的样式与元素本身的属性冲突时</h2>
    <div class="wrapp fix mb20">
        <div class="box r">
            <div class="target target_3"></div>
        </div>
        <div class="cell">
               <pre class="mr10">
.target_3:hover {
  animation-name: move_3;
  animation-duration: 2s;
  animation-delay: 1s;
  animation-fill-mode: both;

  transform: scale(.5,.5) translateZ(0);
}

@keyframes move_3 {
  0% {
    transform: translate(-50px,0);
  }

  50% {
    transform: translate(0,50px);
  }

  100% {
    transform: translate(50px,0);
  }
}
    </pre>
            <div class="pr10">
                .target_3在鼠标hover的时候拥有一个transform的样式，但是由于animation-fill-mode的作用，在动画delay的时间内，.target_3将应用
                .move_3动画0%时的样式，而该帧内定义了另外一个transform的样式，这个时候动画帧内的样式会覆盖元素本身的样式。这一点提醒我们，如果想在动画过程
                中，保持元素动画开始前的状态，那么在关键帧内，需要想办法保留元素本身的样式。像此例，只要在move_3的各个帧内的transform后面，把元素本身定义的
                scale(.5,.5) translateZ(0) 追加到后面即可。
            </div>
        </div>
    </div>
    <h2>4. 应用多个动画时</h2>
    <div class="wrapp fix mb20">
        <div class="box r">
            <div class="target target_4"></div>
        </div>
        <div class="cell">
               <pre class="mr10">
.target_4:hover {
  animation-name: move_4, bg_change;
  animation-duration: 2s, 1s;
  animation-delay: 1s, 1s;
  animation-fill-mode: both;
}

@keyframes move_4 {
  0% {
    transform: translate(-50px, 0);
  }

  50% {
    transform: translate(0, 50px);
  }

  100% {
    transform: translate(50px, 0);
  }
}

@keyframes bg_change {
  0% {
    background-color: orange;
  }

  100% {
    background-color: red;
  }
}
    </pre>
            <div class="pr10">
                从右边的动画实例可以看到，.target-4定义了两个动画，一个是move_4，一个是bg_change，当鼠标移入的时候，尽管bg_change的延迟时间很长，
                但是两个动画的第一帧的样式都应用到了元素上面；在两个动画结束之后，两个动画的最后一帧的样式也都应用到了元素上面。
            </div>
        </div>
    </div>
    <h2>5. 多个动画的第一帧或最后一帧存在样式冲突时</h2>
    <div class="wrapp fix mb20">
        <div class="r">
            <div class="box">
                <div class="target target_5_01"></div>
            </div>
            <div class="box">
                <div class="target target_5_02"></div>
            </div>
        </div>
        <div class="cell">
               <pre class="mr10">
.target_5_01:hover {
  animation-name: move_5, bg_change_5;
  animation-duration: 2s, 1s;
  animation-delay: 1s, 2s;
  animation-fill-mode: both;
}

.target_5_02:hover {
  animation-name: bg_change_5, move_5;
  animation-duration: 2s, 1s;
  animation-delay: 1s, 2s;
  animation-fill-mode: both;
}

@keyframes move_5 {
  0% {
    transform: translate(-50px, 0);
  }

  50% {
    transform: translate(0, 50px);
  }

  100% {
    transform: translate(50px, 0);
  }
}

@keyframes bg_change_5 {
  0% {
    background-color: orange;
    transform: translateZ(100px);
  }

  100% {
    background-color: red;
    transform: translateZ(100px);
  }
}
    </pre>
            <div class="pr10">
                当多个动画的的第一帧或最后一帧样式存在冲突时，按animation-name中定义的动画顺序，后定义的动画的样式将覆盖先定义的动画样式。
            </div>
        </div>
    </div>
</div>
</body>
</html>
